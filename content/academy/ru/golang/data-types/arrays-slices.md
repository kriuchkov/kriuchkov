---
title: 'Массивы и слайсы в Go'
description: 'Различия между массивами и слайсами, их устройство и способы работы с ними.'
category: 'Golang'
date: '2026-02-02'
---

В Go существуют два основных типа структур данных для работы с последовательностями элементов: **массивы** и **слайсы**. Понимание разницы между ними очень важно, так как они играют ключевую роль в управлении памятью и организации данных в Go.

## Массивы в Go

1. **Что такое массив**: Массив в Go — это фиксированная последовательность элементов одного типа. Размер массива задается во время его создания и не может быть изменён. Массивы в Go, как и в других языках, хранятся в непрерывной области памяти.
2. **Синтаксис массивов**:

    ```go
    var arr [5]int // Объявление массива из 5 элементов типа int
    arr[0] = 10    // Присвоение значения элементу массива
    fmt.Println(arr)
    ```

    - Массив `arr` имеет фиксированный размер 5 и может содержать только элементы типа `int`.
    - Если вы попробуете добавить больше элементов, это вызовет ошибку компиляции, так как размер массива фиксирован.

3. **Инициализация массивов**:
    - **Автоматическая инициализация**:

        ```go
        var arr = [5]int{1, 2, 3, 4, 5} // Массив инициализирован значениями
        ```

    - **Краткая форма**:

        ```go
        arr := [3]string{"apple", "banana", "cherry"} // Краткая форма объявления и инициализации
        ```

    - **Инициализация без указания всех элементов**:

        ```go
        arr := [5]int{1, 2} // Остальные элементы будут инициализированы значением по умолчанию (0)
        ```

4. **Доступ к элементам**:
    - Доступ к элементам массива осуществляется с использованием индексов, начиная с 0:

        ```go
        value := arr[2] // Доступ к третьему элементу массива
        ```

5. **Копирование массивов**:
    - Массивы в Go **копируются при присваивании**. Если вы присвоите один массив другому, все элементы будут скопированы:

        ```go
        arr1 := [3]int{1, 2, 3}
        arr2 := arr1         // arr2 — это копия arr1
        arr2[0] = 10         // Изменение arr2 не затронет arr1
        fmt.Println(arr1)    // Вывод: [1, 2, 3]
        fmt.Println(arr2)    // Вывод: [10, 2, 3]
        ```

## Слайсы в Go

1. **Что такое слайс**: Слайс — это гибкая и мощная оболочка над массивом. В отличие от массива, слайс **не имеет фиксированного размера** и может увеличиваться или уменьшаться. Слайс содержит указатель на массив, длину и емкость.
2. **Синтаксис слайсов**:
    - Объявление слайса:

        ```go
        var slice []int // Объявление слайса без указания длины
        ```

    - Инициализация слайса:

        ```go
        slice := []int{1, 2, 3, 4, 5} // Слайс, инициализированный значениями
        ```

3. **Создание слайса из массива**:
    - Слайс можно создать из существующего массива:

        ```go
        arr := [5]int{1, 2, 3, 4, 5}
        slice := arr[1:4] // Слайс, включающий элементы с индексами 1, 2 и 3
        fmt.Println(slice) // Вывод: [2, 3, 4]
        ```

    - **Диапазон**: `arr[start:end]` включает элементы от индекса `start` до `end-1`.

4. **Длина и емкость слайса**:
    - **Длина** (`len(slice)`) — это количество элементов в слайсе.
    - **Емкость** (`cap(slice)`) — это максимальное количество элементов, которое слайс может вместить без выделения новой памяти.

        ```go
        arr := [5]int{1, 2, 3, 4, 5}
        slice := arr[1:4]
        fmt.Println(len(slice)) // Длина: 3
        fmt.Println(cap(slice)) // Емкость: 4 (от элемента с индексом 1 до конца массива)
        ```

5. **Добавление элементов к слайсу**:
    - Для добавления элементов к слайсу используется функция `append`:

        ```go
        slice := []int{1, 2, 3}
        slice = append(slice, 4, 5) // Добавление элементов 4 и 5
        fmt.Println(slice)          // Вывод: [1, 2, 3, 4, 5]
        ```

    - Если емкость слайса недостаточна, `append` выделяет новую область памяти для размещения всех элементов.

6. **Копирование слайсов**:
    - Для копирования элементов из одного слайса в другой используется функция `copy`:

        ```go
        src := []int{1, 2, 3}
        dst := make([]int, len(src))
        copy(dst, src)
        fmt.Println(dst) // Вывод: [1, 2, 3]
        ```

7. **Изменение слайсов**:
    - Слайсы являются ссылочными типами. Если два слайса ссылаются на один и тот же массив и один из них изменяется, изменения отразятся и в другом слайсе:

        ```go
        arr := [5]int{1, 2, 3, 4, 5}
        slice1 := arr[1:4]
        slice2 := arr[2:5]
        slice1[1] = 10             // Изменение slice1 также изменяет arr и slice2
        fmt.Println(arr)           // Вывод: [1, 2, 10, 4, 5]
        fmt.Println(slice2)        // Вывод: [10, 4, 5]
        ```

## Отличия между массивами и слайсами

1. **Размер**:
    - Массив имеет **фиксированный размер**, который задается при его создании.
    - Слайс имеет **динамический размер** и может увеличиваться или уменьшаться.
2. **Тип данных**:
    - Тип массива включает его размер. Например, `[3]int` и `[4]int` — это разные типы.
    - Слайс не включает размер в свой тип. Например, `[]int` всегда является одним и тем же типом, независимо от количества элементов.
3. **Передача по значению и ссылке**:
    - Массивы передаются **по значению**. Это означает, что при передаче массива в функцию копируется весь массив.
    - Слайсы передаются **по ссылке**. Это означает, что передается указатель на массив, что делает слайсы более эффективными в использовании памяти.

## Использование слайсов в реальных задачах

Слайсы используются в Go гораздо чаще, чем массивы, из-за их гибкости и удобства. Они обеспечивают простоту работы с динамическими последовательностями данных, что делает их важной частью языка Go.

## Заключение

- **Массивы**: Используются в Go для простых и фиксированных наборов данных. Поскольку размер массива фиксирован, они реже используются в реальных программах.
- **Слайсы**: Более гибкие и удобные в использовании структуры данных, которые позволяют управлять последовательностями данных динамически. Слайсы обладают высокой производительностью и часто используются в Go-программах.
