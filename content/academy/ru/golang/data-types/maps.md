---
title: 'Map в Go'
description: 'Устройство, использование и особенности Map в Go, включая внутреннюю реализацию и разрешение коллизий.'
category: 'Golang'
date: '2026-02-02'
---

**Map** в Go — это мощный и гибкий инструмент для хранения пар ключ-значение, обеспечивающий быструю доступность данных.
Map легко использовать, но важно помнить, что порядок элементов не гарантирован, и Map не поддерживает сравнение между собой.

## Описание map в Go

map в Go — это ассоциативная структура данных, которая реализует хеш-таблицу. Она используется для хранения пар `ключ-значение`, где каждый ключ уникален, а значение может быть любым.

Основные характеристики map:

- **Неупорядоченность**: элементы в map не имеют определённого порядка.
- **Динамичность**: map автоматически увеличивается или уменьшается по мере добавления или удаления элементов.
- **Быстрый доступ**: операции чтения, записи и удаления имеют среднюю временную сложность O(1) благодаря хеш-таблице.
- **Ограничения на ключи**: ключи должны быть сравнимыми (поддерживать операцию ==), что исключает, например, слайсы, функции и другие map в качестве ключей.
- **Потокобезопасность**: map не является потокобезопасной, и для конкурентного доступа требуется синхронизация (например, через sync.RWMutex).

Синтаксис создания map:

```go
m := make(map[KeyType]ValueType) // Пустая карта
m := map[KeyType]ValueType{key1: value1, key2: value2} // Инициализация с данными
```

## Внутренняя структура map

Внутренне map в Go реализуется как хеш-таблица с разрешением коллизий через цепочки (chaining). Основные компоненты внутренней структуры map описаны в пакете runtime (в файле map.go).

### 1. Структура hmap

Основная структура, представляющая map, называется `hmap`. Её определение в runtime выглядит примерно так (упрощённо):

```go
// A header for a Go map.
type hmap struct {
    count     int // # live cells == size of map. Must be first (used by len() builtin)
    flags     uint8
    B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
    noverflow uint16 // approximate number of overflow buckets
    hash0     uint32 // hash seed
    buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
    oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
    nevacuate  uintptr        // progress counter for evacuation
    extra *mapextra // optional fields
}
```

- **count**: Хранит текущее количество элементов в map.
- **B**: Определяет размер хеш-таблицы (число бакетов = 2^B).
- **buckets**: Указатель на массив бакетов, где каждый бакет содержит до 8 пар ключ-значение.
- **oldbuckets**: Используется при увеличении размера map для постепенной миграции данных (инкрементальное рехеширование).
- **hash0**: Случайное начальное значение для хеш-функции, чтобы избежать предсказуемых коллизий.
- **extra**: Указатель на структуру, содержащую данные о переполненных бакетах.

### 2. Структура bmap (бакет)

Каждый бакет (bmap) хранит до 8 пар ключ-значение. Его структура не определена явно в коде, но фактически включает:

- **tophash**: Массив из 8 байтов, где каждый байт хранит старшие биты хеш-кода ключа для быстрого поиска.
- **keys**: Ключи, хранящиеся последовательно.
- **values**: Значения, хранящиеся последовательно после ключей.
- **overflow**: Указатель на следующий бакет при переполнении (цепочка).

Если в бакете больше 8 элементов (из-за коллизий), создаётся переполненный бакет (overflow), связанный с основным.

### 3. Хеш-функция

Go использует хеш-функцию, зависящую от типа ключа. Для разных типов (например, string, int, структуры) применяются разные алгоритмы хеширования. Хеш-функция генерирует 32- или 64-битное значение.

- Старшие биты (tophash) используются для быстрого поиска в бакете.
- Младшие биты определяют индекс бакета (`hash % 2^B`).

### 4. Рост и рехеширование

map автоматически увеличивается, когда коэффициент загрузки (load factor) превышает 6.5.
При этом:

- Размер хеш-таблицы удваивается.
- Данные постепенно мигрируют из старых бакетов в новые во время операций чтения/записи (инкрементальное рехеширование).

### 5. Итерация

Итерация по map не гарантирует порядок, так как начальная точка итерации рандомизируется.

## Объявление и создание Map

1. **Объявление Map**:

    ```go
    var m map[string]int
    ```

    Здесь `m` имеет значение `nil` и его нужно инициализировать.

2. **Инициализация с помощью `make`**:

    ```go
    m := make(map[string]int)
    ```

3. **Создание и инициализация с элементами**:

    ```go
    m := map[string]int{
        "apple":  5,
        "banana": 10,
        "orange": 15,
    }
    ```

## Добавление, доступ и удаление элементов

1. **Добавление или обновление**:

    ```go
    m["apple"] = 5
    m["apple"] = 8 // Обновление
    ```

2. **Доступ к элементу**:

    ```go
    value := m["apple"]
    ```

    Если ключ не существует, возвращается значение по умолчанию (0 для int).

3. **Проверка наличия ключа**:

    ```go
    value, exists := m["orange"]
    if exists {
        fmt.Println("Key found:", value)
    }
    ```

4. **Удаление элемента**:

    ```go
    delete(m, "banana")
    ```

## Итерация по Map

```go
for key, value := range m {
    fmt.Println(key, value)
}
```

Порядок итерации неопределён.

## Golang 1.24 и Swiss Tables

В Go 1.24 планируется новая реализация map — **Swiss Tables**.

- Классическая реализация использует цепочки (chaining).
- Swiss Tables используют открытую адресацию и специальные метаданные для ускорения поиска.

## Особенности и ограничения

- **Ключи должны быть сравнимыми**: `string`, `int`, `float`, `bool`, массивы, структуры без несравнимых полей. Срезы, map и функции нельзя использовать как ключи.
- **Map — это ссылочный тип**: Передается по ссылке.
- **Map нельзя сравнивать**: Только с `nil`.

## Примеры использования

### Счётчик слов

```go
wordCount := make(map[string]int)
for _, word := range words {
    wordCount[word]++
}
```

### Разрешение коллизий

Go использует метод цепочек. При коллизии (одинаковый хеш) элементы добавляются в связный список внутри бакета (или в overflow бакеты).
При перераспределении (rehashing) размер таблицы увеличивается, и элементы переносятся в новые бакеты. Это происходит инкрементально.
