---
title: 'Goroutines in Go'
description: 'Легковесные потоки в Go: преимущества, устройство, контекст переключения и сравнение с процессами.'
category: 'Golang'
date: '2026-01-30'
---


Горутины – эффективный способ обработки конкурентности и параллелизма в приложениях, требующих высокой масштабируемости и низких затрат на многозадачность.

> Источник: [Backend Interview](https://backendinterview.ru/goLang/concurrency/gouritine.html)

[Go 101: Channels](https://go101.org/article/channel.html)

## Преимущества горутин

Горутины в Go – это легковесные потоки, которые позволяют эффективно выполнять параллельные задачи и обрабатывать конкурентные операции.

Основные преимущества горутин включают:

1. **Легковесность**: В отличие от системных потоков, горутины занимают значительно меньше памяти (обычно около 2 КБ при запуске) и не требуют многозадачности на уровне операционной системы, что позволяет запускать тысячи и даже миллионы горутин одновременно.
2. **Простота в использовании**: Создание новой горутины требует всего одной команды, `go functionName()`, что упрощает процесс создания параллельного кода.
3. **Эффективное управление памятью**: Go оптимизирует использование памяти для горутин и автоматически управляет их стеком, что позволяет экономить ресурсы.
4. **Встроенная поддержка синхронизации**: Для обмена данными и синхронизации Go предоставляет каналы, которые упрощают коммуникацию между горутинами, сохраняя безопасность и предотвращая условия гонки.
5. **Поддержка масштабируемости**: Поскольку Go может эффективно обрабатывать несколько горутин на нескольких ядрах процессора, это позволяет более равномерно распределять нагрузку и улучшает производительность на многоядерных системах.
6. **Отличная поддержка асинхронных операций**: Горутины особенно полезны для задач, которые требуют выполнения асинхронных операций (например, сетевого ввода-вывода), позволяя обрабатывать большое количество запросов одновременно без блокировок.

**Стек** — это область оперативной памяти, которая создаётся для каждой горутины. Он работает по принципу LIFO (Last In, First Out), то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека.

**Куча** — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти: это просто склад для переменных.

> Размер стека настраивается с помощью [метода](https://pkg.go.dev/runtime/debug#SetMaxStack) `runtime.SetMaxStack`.

## Контекст переключения по типам

**Контекст переключения (context switching)** — это процесс, при котором операционная система (или планировщик Go) приостанавливает выполнение одной задачи (например, горутины или потока) и переключается на выполнение другой. Во время этого процесса сохраняется состояние текущей задачи, чтобы можно было возобновить её выполнение в будущем с того же места.

В контексте языка программирования Go и его планировщика, контекст переключения относится к тому, как Go приостанавливает одну горутину и переключается на другую, сохраняя все необходимые данные для правильного возобновления.

### Что включает в себя Контекст Переключения?

Контекст переключения включает сохранение и восстановление следующих данных:

1. **Состояние процессора**:
    - **Регистры процессора**: Все текущие значения регистров (например, указатель инструкций, указатель стека и рабочие регистры) сохраняются, чтобы восстановить их позже.
    - **Флаги состояния процессора**: Сохраняются флаги и другие параметры, которые определяют текущее состояние выполнения.
2. **Контекст выполнения горутины**:
    - **Указатель стека**: Горутины в Go имеют собственные стеки, которые могут динамически расширяться или сжиматься. Планировщик сохраняет указатель стека горутины, чтобы знать, где находится текущая точка выполнения.
    - **Программный счетчик**: Адрес следующей инструкции, которую нужно выполнить, когда горутина возобновится.
    - **Данные, связанные с планировщиком**: Состояние горутины, очереди, в которых она может находиться, и информация о том, какие ресурсы она использует.

### Как происходит Контекст Переключения в Go?

1. **Горутина блокируется**: Когда горутина блокируется, например, ожидая данные из канала, планировщик решает приостановить её. Он сохраняет её контекст, чтобы позже можно было возобновить выполнение.
2. **Сохранение состояния**: Планировщик сохраняет состояние горутины, включая все данные, необходимые для восстановления выполнения (указатель стека, регистры, программный счетчик и т. д.).
3. **Выбор новой горутины**: Планировщик выбирает другую горутину из очереди готовых горутин (*Grunnable*) и восстанавливает её контекст.
4. **Восстановление состояния**: Планировщик восстанавливает сохраненное состояние выбранной горутины и передает управление ей. Горутина продолжает выполнение с того места, где была приостановлена.

### Когда происходит Контекст Переключения?

1. **Блокировка горутины**: Когда горутина блокируется, ожидая данные из канала, освобождения мьютекса или завершения системного вызова.
2. **Принудительное прерывание (Preemption)**: Планировщик Go может прерывать выполнение горутины, если она выполняется слишком долго, чтобы дать другим горутинам возможность выполниться.
3. **Вызов `runtime.Gosched()`**: Горутина может добровольно уступить управление планировщику, вызывая `runtime.Gosched()`, чтобы другие горутины могли выполняться.
4. **Окончание выполнения**: Когда горутина завершает выполнение, планировщик переключается на другую горутину.

### Почему Контекст Переключения важен?

1. **Эффективное распределение ресурсов**: Контекст переключения позволяет планировщику Go эффективно распределять процессорное время между всеми горутинами, обеспечивая справедливость и возможность выполнения всех задач.
2. **Многозадачность**: Контекст переключения обеспечивает многозадачность, позволяя множеству горутин выполняться «одновременно» (или по крайней мере, создавая эту иллюзию) даже на одном ядре процессора.
3. **Реализация конкурентности**: Go делает конкурентное программирование простым и эффективным благодаря механизму горутин и автоматическому управлению переключениями между ними.

### Стоимость Контекст Переключения

Хотя контекст переключения позволяет создавать и управлять большим числом горутин, он всё же имеет свою стоимость:

1. **Затраты на сохранение и восстановление состояния**: Сохранение и восстановление контекста требует времени и ресурсов процессора. Хотя горутины в Go являются легковесными по сравнению с потоками ОС, частые переключения могут повлиять на производительность.
2. **Накладные расходы на планирование**: Планировщик Go использует ресурсы для управления горутинами и принятия решений о том, когда переключаться между ними. Это также может создавать дополнительные накладные расходы.

## Как Go минимизирует накладные расходы?

1. **Легковесные горутины**: Горутины имеют гораздо меньшие накладные расходы по сравнению с потоками ОС, что делает контекст переключения более быстрым и менее затратным.
2. **Оптимизированный планировщик**: Планировщик Go разработан для минимизации накладных расходов на управление и переключение между горутинами.
3. **Динамические стеки**: В Go используются стеки переменного размера, которые могут расширяться или сжиматься в зависимости от потребностей, что также снижает накладные расходы.

### Основные различия

| **Параметр** | **Процессы** | **Треды** | **Горутины** |
| --- | --- | --- | --- |
| **Что сохраняется** | Регистры, память, ресурсы | Регистры, стек | Регистры, небольшой стек |
| **Затраты времени** | Высокие | Средние | Низкие |
| **Уровень управления** | ОС | ОС | Рантайм Go |
| **Системные вызовы** | Требуются | Требуются | Не требуются |
