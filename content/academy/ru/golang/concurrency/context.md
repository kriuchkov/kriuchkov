---
title: 'Пакет context'
description: 'Управление потоком выполнения, дедлайны и отмена операций с помощью пакета context.'
category: 'Golang'
date: '2026-02-02'
---

Контекст (`context.Context`) — это механизм для управления временем выполнения операций, отмены сигналов и передачи значений между горутинами.

## Для чего используется контекст

- **Deadline**: Установка крайнего срока выполнения операции (тайм-аут).
- **Cancellation**: Оповещение об отмене выполнения (например, когда клиент разорвал соединение или родительская задача отменена).
- **Values**: Передача данных (Request ID, User ID, логгер) по цепочке вызовов.

## Создание контекста

- `context.Background()`: Корневой пустой контекст. Обычно создается в `main` или обработчике запроса.
- `context.TODO()`: Пустой контекст, используемый как заглушка, когда пока неясно, какой контекст использовать.

## Основные функции

### `WithCancel`

```go
ctx, cancel := context.WithCancel(parentCtx)
defer cancel() // Всегда вызывайте cancel для освобождения ресурсов
```

Возвращает копию родительского контекста с каналом `Done`, который закрывается при вызове `cancel()`.

### `WithTimeout` / `WithDeadline`

```go
ctx, cancel := context.WithTimeout(parentCtx, 5*time.Second)
defer cancel()
```

Автоматически отменяет контекст по истечении времени.

### `WithValue`

```go
ctx := context.WithValue(parentCtx, "key", "value")
```

ДОбавляет пару ключ-значение. **Важно**: используйте пользовательские типы для ключей, чтобы избежать коллизий.

### `WithoutCancel` (Go 1.21+)

```go
ctx := context.WithoutCancel(parentCtx)
```

Создает копию контекста, которая не отменяется при отмене родительского. Используется для операций очистки (cleanup) или rollback, которые должны выполниться даже если основной запрос отменен.

### `AfterFunc` (Go 1.21+)

```go
stop := context.AfterFunc(ctx, func() {
    fmt.Println("Context cancelled")
})
```

Выполняет функцию в своей горутине, когда контекст отменяется.

## Использование в горутинах

```go
func operation(ctx context.Context) {
    select {
    case <-time.After(1 * time.Second):
        fmt.Println("Done")
    case <-ctx.Done():
        fmt.Println("Cancelled:", ctx.Err())
    }
}
```

Горутина должна всегда проверять `ctx.Done()` для корректного завершения при отмене.
