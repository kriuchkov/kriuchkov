---
title: 'Пакет sync'
description: 'Примитивы синхронизации в Go: Mutex, RWMutex, WaitGroup, Once, Cond.'
category: 'Golang'
date: '2026-02-02'
---

Пакет `sync` предоставляет базовые примитивы синхронизации для управления конкурентным доступом к памяти.

## Примитивы синхронизации

### 1. `sync.Mutex`

Взаимная блокировка (mutual exclusion). Гарантирует, что только одна горутина владеет ресурсом.

```go
var mu sync.Mutex
mu.Lock()
// Критическая секция
mu.Unlock()
```

### 2. `sync.RWMutex`

Мьютекс с разделением на чтение и запись.

- `RLock()` / `RUnlock()`: Множество читателей могут владеть блокировкой одновременно.
- `Lock()` / `Unlock()`: Только один писатель, блокирует и читателей, и писателей.

Эффективен, когда чтение происходит гораздо чаще записи.

### 3. `sync.WaitGroup`

Используется для ожидания завершения группы горутин.

```go
var wg sync.WaitGroup
for i := 0; i < 5; i++ {
    wg.Add(1)
    go func() {
        defer wg.Done()
        // Работа
    }()
}
wg.Wait() // Блокируется, пока счетчик не станет 0
```

### 4. `sync.Once`

Гарантирует, что функция будет вызвана ровно один раз. Часто используется для ленивой инициализации синглтонов.

```go
var once sync.Once
once.Do(func() {
    fmt.Println("Init")
})
```

### 5. `sync.Cond`

Условная переменная. Точка синхронизации, где горутины могут ждать выполнения определенного условия и оповещать друг друга.

- `Wait()`: Ждет сигнала (освобождает блокировку и засыпает).
- `Signal()`: Будит одну горутину.
- `Broadcast()`: Будит все ждущие горутины.

### 6. `sync.Map`

Потокобезопасная map. Оптимизирована для двух случаев:

1. Ключи записываются один раз и читаются много раз (cache).
2. Разные горутины работают с непересекающимися наборами ключей.

В остальных случаях обычная `map` + `RWMutex` может быть быстрее и типобезопаснее.

### 7. `sync.Pool`

Пул объектов для переиспользования памяти и снижения нагрузки на GC.
